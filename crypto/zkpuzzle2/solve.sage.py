

# This file was *autogenerated* from the file ./solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031303 = Integer(86844398212127729389856047074289654044187498228644074447276846288751135031303); _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031309 = Integer(86844398212127729389856047074289654044187498228644074447276846288751135031309); _sage_const_0 = Integer(0); _sage_const_12 = Integer(12); _sage_const_6 = Integer(6); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_399 = Integer(399); _sage_const_5p0 = RealNumber('5.0'); _sage_const_100 = Integer(100); _sage_const_8 = Integer(8); _sage_const_1p0 = RealNumber('1.0'); _sage_const_3 = Integer(3); _sage_const_10000 = Integer(10000); _sage_const_20_000 = Integer(20_000); _sage_const_50 = Integer(50); _sage_const_0p15 = RealNumber('0.15'); _sage_const_100_000 = Integer(100_000); _sage_const_80 = Integer(80); _sage_const_0p25 = RealNumber('0.25'); _sage_const_500_000 = Integer(500_000); _sage_const_120 = Integer(120); _sage_const_0p40 = RealNumber('0.40'); _sage_const_2_000_000 = Integer(2_000_000); _sage_const_180 = Integer(180); _sage_const_0p70 = RealNumber('0.70'); _sage_const_10_000_000 = Integer(10_000_000); _sage_const_250 = Integer(250); _sage_const_1p20 = RealNumber('1.20'); _sage_const_200_000 = Integer(200_000); _sage_const_9 = Integer(9); _sage_const_18 = Integer(18); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_23 = Integer(23); _sage_const_26 = Integer(26); _sage_const_30 = Integer(30); _sage_const_7 = Integer(7); _sage_const_29 = Integer(29); _sage_const_27 = Integer(27); _sage_const_18454 = Integer(18454); _sage_const_954 = Integer(954)
from pwn import *
from sage.all import *
from tqdm import trange
import subprocess, time, re, os
import multiprocessing as mp
from collections import Counter
os.environ.setdefault("OMP_NUM_THREADS", "1")

p = _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031303 
q = _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031309 
N = p*q

def worker_find_sm(N, tgt0, offset, stride, timeout_s, bits_limit, outq, stop_event):
    # Each worker searches tgt = tgt0 + (offset + stride*j)*N
    j = _sage_const_0 
    while not stop_event.is_set():
        tgt = tgt0 + (offset + stride * j) * _sage_const_12  * N
        
        assert tgt % _sage_const_12  == _sage_const_6 

        # Keep your congruence filter
        if tgt % _sage_const_12  == _sage_const_6 :
            factors, cofactor = ecm_partial_factor(tgt, timeout_s=timeout_s)
            sm = max([*factors, cofactor])  # matches your code
            print(f'{sm.nbits() = }')
            df = tgt // _sage_const_6  // sm
            u, v = (sm+df)//_sage_const_2 , (sm-df)//_sage_const_2 
            arr = [_sage_const_1 +u,_sage_const_1 -u,-_sage_const_1 +v,-_sage_const_1 -v]
            if u < _sage_const_2 **_sage_const_399 :
                # return arr
            # if sm.nbits() < bits_limit:
                outq.put(arr)
                stop_event.set()
                return

        j += _sage_const_1 
        
       # factors, cofactor = ecm_partial_factor(tgt, timeout_s=5.0)
        # sm = max([*factors,cofactor])
        # print(f'{sm.nbits() = }')
        # df = tgt // 6 // sm
        # u, v = (sm+df)//2, (sm-df)//2
        # arr = [1+u,1-u,-1+v,-1-v]
        # if u < 2**399:
            # return arr

def parallel_search_sm(N, tgt_start, timeout_s=_sage_const_5p0 , bits_limit=_sage_const_100 , n_workers=_sage_const_8 ):
    """
    Returns sm from the first worker to succeed.
    """
    ctx = mp.get_context("spawn")  # safer in Sage/Jupyter than fork
    outq = ctx.Queue()
    stop_event = ctx.Event()

    procs = []
    for w in range(n_workers):
        proc = ctx.Process(
            target=worker_find_sm,
            args=(N, tgt_start, w, n_workers, timeout_s, bits_limit, outq, stop_event),
            daemon=True,
        )
        proc.start()
        procs.append(proc)

    try:
        sm = outq.get()  # blocks until a worker puts a result
        return sm
    finally:
        stop_event.set()
        for proc in procs:
            if proc.is_alive():
                proc.terminate()
        for proc in procs:
            proc.join(timeout=_sage_const_1p0 )

def _run_gmp_ecm_one_factor(n, seconds, B1, curves, ecm_path="ecm"):
    """
    Try to find ONE nontrivial factor of n using GMP-ECM with given params.
    Returns Integer(factor) or None.
    Hard wall-clock timeout via subprocess.
    """
    n = Integer(n)
    if n <= _sage_const_3 :
        return None
    if is_prime(n):
        return None

    cmd = [ecm_path, "-q", "-one", "-c", str(curves), str(B1)]
    try:
        # print('RUNNING', curves, B1)
        cp = subprocess.run(
            cmd,
            input=str(n).encode(),
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            timeout=float(seconds),
            check=False,
        )
    except subprocess.TimeoutExpired:
        return None

    out = cp.stdout.decode(errors="ignore")

    # Robust parsing: grab all "big-ish" integers in output, test divisibility.
    # (GMP-ECM output format varies by version/options.)
    for m in re.finditer(r"\d{2,}", out):
        d = Integer(m.group(_sage_const_0 ))
        if _sage_const_1  < d < n and n % d == _sage_const_0 :
            return d

    return None

def ecm_partial_factor(N, timeout_s, ecm_path="ecm",
                       ladder=None,
                       do_small_trial_division=True,
                       trial_limit=_sage_const_10000 ):
    """
    Partially factor N using ECM for at most timeout_s seconds.

    Returns:
      (factors_counter, cofactor)
    where factors_counter is a Counter mapping factor -> multiplicity.
    Factors found may be composite (ECM gives nontrivial splits).
    """

    N = Integer(N)
    if N == _sage_const_0 :
        raise ValueError("N must be nonzero.")
    if N < _sage_const_0 :
        N = -N  # factor sign separately if you care

    # A reasonable default parameter ladder for ~512-bit inputs.
    # Each attempt tries to find *one* factor; we loop until time runs out.
    if ladder is None:
        ladder = [
            # (B1, curves, max_seconds_for_this_attempt)
            (_sage_const_20_000 ,     _sage_const_50 ,  _sage_const_0p15 ),
            (_sage_const_100_000 ,    _sage_const_80 ,  _sage_const_0p25 ),
            (_sage_const_500_000 ,   _sage_const_120 ,  _sage_const_0p40 ),
            (_sage_const_2_000_000 , _sage_const_180 ,  _sage_const_0p70 ),
            (_sage_const_10_000_000 ,_sage_const_250 ,  _sage_const_1p20 ),
        ]
        ladder = [
            (_sage_const_200_000 , _sage_const_50 , _sage_const_5p0 )
        ]

    factors = Counter()
    start = time.time()

    # Optional: cheap trial division knocks out small primes quickly.
    if do_small_trial_division and N > _sage_const_1 :
        # trial_limit ~ 10k is cheap; adjust as you like
        # (still "ECM-focused", but this is just low-hanging fruit)
        from sage.all import prime_range
        for p in prime_range(trial_limit + _sage_const_1 ):
            p = Integer(p)
            if N % p == _sage_const_0 :
                e = _sage_const_0 
                while N % p == _sage_const_0 :
                    N //= p
                    e += _sage_const_1 
                factors[p] += e
            if N == _sage_const_1 :
                return factors, Integer(_sage_const_1 )

    # Main loop: keep splitting off factors while time remains.
    while N > _sage_const_1  and not is_prime(N):
        elapsed = time.time() - start
        remaining_total = timeout_s - elapsed
        if remaining_total <= _sage_const_0 :
            break

        got_factor = False

        for (B1, curves, cap) in ladder:
            elapsed = time.time() - start
            remaining_total = timeout_s - elapsed
            if remaining_total <= _sage_const_0 :
                break

            attempt_time = min(float(cap), float(remaining_total))
            d = _run_gmp_ecm_one_factor(N, attempt_time, B1, curves, ecm_path=ecm_path)
            if d is None:
                continue

            # Split N by d; record d and continue (d may be composite)
            factors[d] += _sage_const_1 
            N //= d
            got_factor = True
            break  # go back to the while-loop on the reduced N

        if not got_factor:
            # No factor found with our ladder before the remaining budget ran out
            break

    # If leftover is >1 and prime, include it (we "found" it by finishing)
    if N > _sage_const_1  and is_prime(N):
        factors[N] += _sage_const_1 
        N = Integer(_sage_const_1 )

    return factors, N

def four_cubes_demjanenko(n: int):
    """
    Return (a,b,c,d) such that a^3 + b^3 + c^3 + d^3 == n,
    using the 5 explicit identities from Wikipedia's Sum of four cubes problem page.

    Preconditions for this construction:
      n % 9 not in {4,5}   (i.e. n not congruent to ±4 mod 9)
      n % 18 not in {2,16} (i.e. n not congruent to ±2 mod 18)

    Raises ValueError if n falls in excluded residue classes.

    Note: This is an *exact integer* decomposition, not just mod something.
    """
    r9 = n % _sage_const_9 
    r18 = n % _sage_const_18 

    if r9 in (_sage_const_4 , _sage_const_5 ):
        # raise ValueError("This Demjanenko formula set does not cover n ≡ ±4 (mod 9).")
        return
    if r18 in (_sage_const_2 , _sage_const_16 ):
        # raise ValueError("This Demjanenko formula set (as requested) excludes n ≡ ±2 (mod 18).")
        return

    # Handle "opposites": if we can do -n, then negate all outputs to get n.
    if r18 in (_sage_const_17 , _sage_const_11 , _sage_const_10 ):  # -1, -7, -8 mod 18
        a, b, c, d = four_cubes_demjanenko(-n)
        return (-a, -b, -c, -d)

    # Now r18 is one of: 0,1,3,6,7,8,9,12,15
    if r18 in (_sage_const_0 , _sage_const_6 , _sage_const_12 ):
        # 6x = (x+1)^3 + (x-1)^3 - x^3 - x^3
        x = n // _sage_const_6 
        return (x + _sage_const_1 , x - _sage_const_1 , -x, -x)

    if r18 in (_sage_const_3 , _sage_const_9 , _sage_const_15 ):
        # 6x+3 = x^3 + (-x+4)^3 + (2x-5)^3 + (-2x+4)^3
        x = (n - _sage_const_3 ) // _sage_const_6 
        return (x, -x + _sage_const_4 , _sage_const_2 *x - _sage_const_5 , -_sage_const_2 *x + _sage_const_4 )

    if r18 == _sage_const_1 :
        # 18x+1 = (2x+14)^3 + (-2x-23)^3 + (-3x-26)^3 + (3x+30)^3
        x = (n - _sage_const_1 ) // _sage_const_18 
        return (_sage_const_2 *x + _sage_const_14 , -_sage_const_2 *x - _sage_const_23 , -_sage_const_3 *x - _sage_const_26 , _sage_const_3 *x + _sage_const_30 )

    if r18 == _sage_const_7 :
        # 18x+7 = (x+2)^3 + (6x-1)^3 + (8x-2)^3 + (-9x+2)^3
        x = (n - _sage_const_7 ) // _sage_const_18 
        return (x + _sage_const_2 , _sage_const_6 *x - _sage_const_1 , _sage_const_8 *x - _sage_const_2 , -_sage_const_9 *x + _sage_const_2 )

    if r18 == _sage_const_8 :
        # 18x+8 = (x-5)^3 + (-x+14)^3 + (-3x+29)^3 + (3x-30)^3
        x = (n - _sage_const_8 ) // _sage_const_18 
        return (x - _sage_const_5 , -x + _sage_const_14 , -_sage_const_3 *x + _sage_const_29 , _sage_const_3 *x - _sage_const_30 )

def solve_round(r, k):
    
    if r % _sage_const_3  != _sage_const_0  and k % _sage_const_3  == _sage_const_0 :
        r *= _sage_const_27 
        k //= _sage_const_3 
    arr = four_cubes_demjanenko(r)
    if arr:
        return [x*k for x in arr]
        
    # otherwise fail
    
    tgt = r*k**_sage_const_3 %N
    while tgt % _sage_const_12  != _sage_const_6 :
        tgt += N
    arr = parallel_search_sm(N, tgt, timeout_s=_sage_const_5p0 , bits_limit=_sage_const_100 , n_workers=_sage_const_8 )
    return arr
    
    # while True:
        # tgt += N
        # if tgt % 12 != 6:
            # continue
        
        # factors, cofactor = ecm_partial_factor(tgt, timeout_s=5.0)
        # sm = max([*factors,cofactor])
        # print(f'{sm.nbits() = }')
        # df = tgt // 6 // sm
        # u, v = (sm+df)//2, (sm-df)//2
        # arr = [1+u,1-u,-1+v,-1-v]
        # if u < 2**399:
            # return arr

if __name__ == "__main__":
    # context.log_level = 'debug'
    # io = process(['sage', 'zk2.sage'])
    io = remote('instance.penguin.0ops.sjtu.cn', _sage_const_18454 )
    io.sendline(f'{p} {q}'.encode())

    w0 = walltime()
    for _ in range(_sage_const_954 ):
        r, k = [int(io.recvregex(b'([0-9]+),', capture=True).group(_sage_const_1 )) for _ in 'rk']
        wt = walltime()
        sol = solve_round(r, k)
        total = walltime(w0)
        print(f'Completed round {_+_sage_const_1 } in {walltime(wt)}. Total time {total}. Average time {total/(_+_sage_const_1 )}')
        io.sendline(str(sol).encode())

    io.interactive()

