

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031303 = Integer(86844398212127729389856047074289654044187498228644074447276846288751135031303); _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031309 = Integer(86844398212127729389856047074289654044187498228644074447276846288751135031309); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_10000 = Integer(10000); _sage_const_200_000 = Integer(200_000); _sage_const_50 = Integer(50); _sage_const_5p0 = RealNumber('5.0'); _sage_const_6 = Integer(6); _sage_const_2 = Integer(2); _sage_const_399 = Integer(399); _sage_const_12 = Integer(12); _sage_const_100 = Integer(100); _sage_const_8 = Integer(8); _sage_const_1p0 = RealNumber('1.0'); _sage_const_9 = Integer(9); _sage_const_18 = Integer(18); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_23 = Integer(23); _sage_const_26 = Integer(26); _sage_const_30 = Integer(30); _sage_const_7 = Integer(7); _sage_const_29 = Integer(29); _sage_const_27 = Integer(27); _sage_const_18383 = Integer(18383); _sage_const_954 = Integer(954)
import os
import re
import subprocess
import time
import multiprocessing as mp
from collections import Counter

from pwn import *
from sage.all import *

os.environ.setdefault("OMP_NUM_THREADS", "1")

p = _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031303 
q = _sage_const_86844398212127729389856047074289654044187498228644074447276846288751135031309 
N = p * q


def _run_gmp_ecm_one_factor(n, seconds, B1, curves, ecm_path="ecm"):
    n = Integer(n)
    if n <= _sage_const_3  or is_prime(n):
        return None

    cmd = [ecm_path, "-q", "-one", "-c", str(curves), str(B1)]
    try:
        cp = subprocess.run(
            cmd,
            input=str(n).encode(),
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            timeout=float(seconds),
            check=False,
        )
    except subprocess.TimeoutExpired:
        return None

    out = cp.stdout.decode(errors="ignore")
    for match in re.finditer(r"\d{2,}", out):
        d = Integer(match.group(_sage_const_0 ))
        if _sage_const_1  < d < n and n % d == _sage_const_0 :
            return d

    return None


def ecm_partial_factor(
    N,
    timeout_s,
    ecm_path="ecm",
    ladder=None,
    do_small_trial_division=True,
    trial_limit=_sage_const_10000 ,
):
    N = Integer(N)
    if N == _sage_const_0 :
        raise ValueError("N must be nonzero.")
    if N < _sage_const_0 :
        N = -N

    if ladder is None:
        ladder = [(_sage_const_200_000 , _sage_const_50 , _sage_const_5p0 )]

    factors = Counter()
    start = time.time()

    if do_small_trial_division and N > _sage_const_1 :
        from sage.all import prime_range

        for p in prime_range(trial_limit + _sage_const_1 ):
            p = Integer(p)
            if N % p != _sage_const_0 :
                continue
            exponent = _sage_const_0 
            while N % p == _sage_const_0 :
                N //= p
                exponent += _sage_const_1 
            factors[p] += exponent
            if N == _sage_const_1 :
                return factors, Integer(_sage_const_1 )

    while N > _sage_const_1  and not is_prime(N):
        elapsed = time.time() - start
        remaining_total = timeout_s - elapsed
        if remaining_total <= _sage_const_0 :
            break

        found = False
        for (B1, curves, cap) in ladder:
            elapsed = time.time() - start
            remaining_total = timeout_s - elapsed
            if remaining_total <= _sage_const_0 :
                break

            attempt_time = min(float(cap), float(remaining_total))
            d = _run_gmp_ecm_one_factor(N, attempt_time, B1, curves, ecm_path=ecm_path)
            if d is None:
                continue

            factors[d] += _sage_const_1 
            N //= d
            found = True
            break

        if not found:
            break

    if N > _sage_const_1  and is_prime(N):
        factors[N] += _sage_const_1 
        N = Integer(_sage_const_1 )

    return factors, N


def _target_candidates(tgt_start, offset, stride, modulus):
    step = offset
    while True:
        yield tgt_start + step * modulus
        step += stride


def _extract_solution(tgt, timeout_s):
    factors, cofactor = ecm_partial_factor(tgt, timeout_s=timeout_s)
    sm = max([*factors, cofactor])
    print(f"{sm.nbits() = }")

    df = tgt // _sage_const_6  // sm
    u = (sm + df) // _sage_const_2 
    v = (sm - df) // _sage_const_2 
    arr = [_sage_const_1  + u, _sage_const_1  - u, -_sage_const_1  + v, -_sage_const_1  - v]
    if u < _sage_const_2 **_sage_const_399 :
        return arr
    return None


def worker_find_sm(N, tgt0, offset, stride, timeout_s, bits_limit, outq, stop_event):
    modulus = _sage_const_12  * N
    for tgt in _target_candidates(tgt0, offset, stride, modulus):
        if stop_event.is_set():
            return

        if tgt % _sage_const_12  != _sage_const_6 :
            continue

        arr = _extract_solution(tgt, timeout_s)
        if arr:
            outq.put(arr)
            stop_event.set()
            return


def parallel_search_sm(N, tgt_start, timeout_s=_sage_const_5p0 , bits_limit=_sage_const_100 , n_workers=_sage_const_8 ):
    ctx = mp.get_context("spawn")
    outq = ctx.Queue()
    stop_event = ctx.Event()

    procs = []
    for worker_id in range(n_workers):
        proc = ctx.Process(
            target=worker_find_sm,
            args=(N, tgt_start, worker_id, n_workers, timeout_s, bits_limit, outq, stop_event),
            daemon=True,
        )
        proc.start()
        procs.append(proc)

    try:
        return outq.get()
    finally:
        stop_event.set()
        for proc in procs:
            if proc.is_alive():
                proc.terminate()
        for proc in procs:
            proc.join(timeout=_sage_const_1p0 )


def four_cubes_demjanenko(n: int):
    r9 = n % _sage_const_9 
    r18 = n % _sage_const_18 

    if r9 in (_sage_const_4 , _sage_const_5 ):
        return
    if r18 in (_sage_const_2 , _sage_const_16 ):
        return

    if r18 in (_sage_const_17 , _sage_const_11 , _sage_const_10 ):
        a, b, c, d = four_cubes_demjanenko(-n)
        return (-a, -b, -c, -d)

    if r18 in (_sage_const_0 , _sage_const_6 , _sage_const_12 ):
        x = n // _sage_const_6 
        return (x + _sage_const_1 , x - _sage_const_1 , -x, -x)

    if r18 in (_sage_const_3 , _sage_const_9 , _sage_const_15 ):
        x = (n - _sage_const_3 ) // _sage_const_6 
        return (x, -x + _sage_const_4 , _sage_const_2  * x - _sage_const_5 , -_sage_const_2  * x + _sage_const_4 )

    if r18 == _sage_const_1 :
        x = (n - _sage_const_1 ) // _sage_const_18 
        return (_sage_const_2  * x + _sage_const_14 , -_sage_const_2  * x - _sage_const_23 , -_sage_const_3  * x - _sage_const_26 , _sage_const_3  * x + _sage_const_30 )

    if r18 == _sage_const_7 :
        x = (n - _sage_const_7 ) // _sage_const_18 
        return (x + _sage_const_2 , _sage_const_6  * x - _sage_const_1 , _sage_const_8  * x - _sage_const_2 , -_sage_const_9  * x + _sage_const_2 )

    if r18 == _sage_const_8 :
        x = (n - _sage_const_8 ) // _sage_const_18 
        return (x - _sage_const_5 , -x + _sage_const_14 , -_sage_const_3  * x + _sage_const_29 , _sage_const_3  * x - _sage_const_30 )


def _normalize_inputs(r, k):
    if r % _sage_const_3  != _sage_const_0  and k % _sage_const_3  == _sage_const_0 :
        return r * _sage_const_27 , k // _sage_const_3 
    return r, k


def _align_target(tgt, modulus, residue, step):
    while tgt % modulus != residue:
        tgt += step
    return tgt


def solve_round(r, k):
    r, k = _normalize_inputs(r, k)
    arr = four_cubes_demjanenko(r)
    if arr:
        return [x * k for x in arr]

    tgt = _align_target(r * k**_sage_const_3  % N, _sage_const_12 , _sage_const_6 , N)
    return parallel_search_sm(N, tgt, timeout_s=_sage_const_5p0 , bits_limit=_sage_const_100 , n_workers=_sage_const_8 )


def _read_round(io):
    return tuple(int(io.recvregex(b"([0-9]+),", capture=True).group(_sage_const_1 )) for _ in "rk")


def run_solver():
    # context.log_level = 'debug'
    # io = process(['sage', 'zk2.sage'])
    io = remote("instance.penguin.0ops.sjtu.cn", _sage_const_18383 )
    io.sendline(f"{p} {q}".encode())

    w0 = walltime()
    for idx in range(_sage_const_954 ):
        r, k = _read_round(io)
        wt = walltime()
        sol = solve_round(r, k)
        total = walltime(w0)
        print(f"Completed round {idx + _sage_const_1 } in {walltime(wt)}. Total time {total}. Average time {total/(idx + _sage_const_1 )}")
        io.sendline(str(sol).encode())

    io.interactive()


if __name__ == "__main__":
    run_solver()

